'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

exports.default = start;

var _redux = require('redux');

var _addons = require('@storybook/addons');

var _addons2 = _interopRequireDefault(_addons);

var _global = require('global');

var _channelPostmessage = require('@storybook/channel-postmessage');

var _channelPostmessage2 = _interopRequireDefault(_channelPostmessage);

var _key_events = require('@storybook/ui/dist/libs/key_events');

var _clientLogger = require('@storybook/client-logger');

var _story_store = require('./story_store');

var _story_store2 = _interopRequireDefault(_story_store);

var _client_api = require('./client_api');

var _client_api2 = _interopRequireDefault(_client_api);

var _config_api = require('./config_api');

var _config_api2 = _interopRequireDefault(_config_api);

var _reducer = require('./reducer');

var _reducer2 = _interopRequireDefault(_reducer);

var _actions = require('./actions');

var Actions = _interopRequireWildcard(_actions);

var _syncUrlWithStore = require('./syncUrlWithStore');

var _syncUrlWithStore2 = _interopRequireDefault(_syncUrlWithStore);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var classes = {
  MAIN: 'sb-show-main',
  NOPREVIEW: 'sb-show-nopreview',
  ERROR: 'sb-show-errordisplay'
};

function showMain() {
  _global.document.body.classList.remove(classes.NOPREVIEW);
  _global.document.body.classList.remove(classes.ERROR);

  _global.document.body.classList.add(classes.MAIN);
}

function showNopreview() {
  _global.document.body.classList.remove(classes.MAIN);
  _global.document.body.classList.remove(classes.ERROR);

  _global.document.body.classList.add(classes.NOPREVIEW);
}

function showErrorDisplay(_ref) {
  var message = _ref.message,
      stack = _ref.stack;

  _global.document.getElementById('error-message').textContent = message;
  _global.document.getElementById('error-stack').textContent = stack;

  _global.document.body.classList.remove(classes.MAIN);
  _global.document.body.classList.remove(classes.NOPREVIEW);

  _global.document.body.classList.add(classes.ERROR);
}

function showError(_ref2) {
  var title = _ref2.title,
      description = _ref2.description;

  showErrorDisplay({
    message: title,
    stack: description
  });
}

function showException(exception) {
  showErrorDisplay(exception);

  // Log the stack to the console. So, user could check the source code.
  _clientLogger.logger.error(exception.stack);
}

function start(render) {
  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      decorateStory = _ref3.decorateStory;

  // check whether we're running on node/browser
  var isBrowser = _global.navigator && _global.navigator.userAgent && _global.navigator.userAgent !== 'storyshots' && !(_global.navigator.userAgent.indexOf('Node.js') > -1) && !(_global.navigator.userAgent.indexOf('jsdom') > -1);

  var storyStore = new _story_store2.default();
  var reduxStore = (0, _redux.createStore)(_reducer2.default);
  var context = {
    storyStore: storyStore,
    reduxStore: reduxStore,
    decorateStory: decorateStory,
    showMain: showMain,
    showError: showError,
    showException: showException
  };

  var clientApi = new _client_api2.default(context);

  var channel = void 0;
  if (isBrowser) {
    // setup preview channel
    channel = (0, _channelPostmessage2.default)({ page: 'preview' });
    channel.on('setCurrentStory', function (data) {
      reduxStore.dispatch(Actions.selectStory(data.kind, data.story));
    });
    _addons2.default.setChannel(channel);
    (0, _assign2.default)(context, { channel: channel });

    (0, _syncUrlWithStore2.default)(reduxStore);

    // Handle keyboard shortcuts
    _global.window.onkeydown = (0, _key_events.handleKeyboardShortcuts)(channel);
  }

  // Provide access to external scripts if `window` is defined.
  // NOTE this is different to isBrowser, primarily for the JSDOM use case
  if (typeof _global.window !== 'undefined') {
    _global.window.__STORYBOOK_CLIENT_API__ = clientApi;
    _global.window.__STORYBOOK_ADDONS_CHANNEL__ = channel; // may not be defined
  }

  var clearDecorators = clientApi.clearDecorators;

  var configApi = new _config_api2.default((0, _extends3.default)({ clearDecorators: clearDecorators }, context));

  var previousKind = '';
  var previousStory = '';
  var previousRevision = -1;

  var renderMain = function renderMain(forceRender) {
    if (storyStore.size() === 0) {
      showNopreview();
      return;
    }

    var _reduxStore$getState = reduxStore.getState(),
        selectedKind = _reduxStore$getState.selectedKind,
        selectedStory = _reduxStore$getState.selectedStory;

    var revision = storyStore.getRevision();
    var story = storyStore.getStoryWithContext(selectedKind, selectedStory);
    if (!story) {
      showNopreview();
      return;
    }

    // Render story only if selectedKind or selectedStory has changed.
    // renderMain() gets executed after each action. Actions will cause the whole
    // story to re-render without this check.
    //    https://github.com/storybooks/react-storybook/issues/116
    // However, we do want the story to re-render if the store itself has changed
    // (which happens at the moment when HMR occurs)
    if (!forceRender && revision === previousRevision && selectedKind === previousKind && previousStory === selectedStory) {
      return;
    }

    // Scroll to top of the page when changing story
    _global.document.documentElement.scrollTop = 0;
    previousRevision = revision;
    previousKind = selectedKind;
    previousStory = selectedStory;

    render((0, _extends3.default)({}, context, {
      story: story,
      selectedKind: selectedKind,
      selectedStory: selectedStory
    }));
  };

  // initialize the UI
  var renderUI = function renderUI(forceRender) {
    if (isBrowser) {
      var _reduxStore$getState2 = reduxStore.getState(),
          error = _reduxStore$getState2.error;

      if (error) {
        showException(error);
        return;
      }
      try {
        renderMain(forceRender);
      } catch (ex) {
        showException(ex);
      }
    }
  };

  renderUI();
  reduxStore.subscribe(renderUI);

  return { context: context, clientApi: clientApi, configApi: configApi, forceReRender: function forceReRender() {
      return renderUI(true);
    } };
}